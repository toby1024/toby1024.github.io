<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Designpatterns | Jason's drunk words]]></title>
  <link href="http://toby1024.github.io/blog/categories/designpatterns/atom.xml" rel="self"/>
  <link href="http://toby1024.github.io/"/>
  <updated>2020-11-25T10:29:02+08:00</updated>
  <id>http://toby1024.github.io/</id>
  <author>
    <name><![CDATA[jason3305@126.com]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式-行为篇]]></title>
    <link href="http://toby1024.github.io/blog/2020/11/09/designpatterns1/"/>
    <updated>2020-11-09T11:04:08+08:00</updated>
    <id>http://toby1024.github.io/blog/2020/11/09/designpatterns1</id>
    <content type="html"><![CDATA[<p><img src="/images/DesignPatterns/202011091107.png"></p>

<!--more-->


<h2>状态模式</h2>

<h3>有限状态机</h3>

<p>1:状态转换较多，但每个状态的转换业务不复杂的，推荐使用查表法。 <br>
通过二维数组等方式确定下一个转换的状态，并处理对应业务<br>
2:状态转换业务较复杂的，推荐使用状态模式，使用单独的类来定义状态和状态业务<br>
3:业务非常简单，状态也很少，直接使用if else就可以实现，不需要过度设计<br></p>

<h3>迭代器模式</h3>

<p>通过模拟游标的滑动来遍历集合中的数据<br>
迭代器需要实现 hasNext，currentItem，next三个方法，用于滑动游标和判断是否迭代结束<br>
遍历过程中不支持元素的添加和删除操作，因为会引起未决结果<br></p>

<h2>访问者模式</h2>

<p>一个或多个操作应用到一组对象上，设计的意图是解耦操作和对象本身，保持类的职责单一、满足开闭原则已应对代码的复杂性。<br>
推荐使用策略模式替代访问者模式。1:访问者模式使用重载实现，容易让访问者代码爆炸。2:不巧妙，不灵活，将一组操作封装在一起，增加功能时需要修改的代码太多。<br>
支持Double Dispatch的语言不需要访问者模式，直接动态执行就可以了<br></p>

<h2>备忘录模式</h2>

<p>1:备份以便于恢复数据<br>
2:不能破坏封装原则<br>
3:低频率全量备份结合高频率增量备份（redis RDF和AOF）<br></p>

<h2>命令模式</h2>

<p>1:将行为封装成对象进行传递<br>
2:和策略模式的区别在于，每个命令执行的是不同的业务；策略模式指同一个业务的不同实现。<br>
例如：控制电灯的开，关属于命令；是交流电还是直流电给电灯供电属于策略。<br></p>

<h2>解释器模式</h2>

<p>典型的场景是编译器的语法解释。<br>
解释器是针对特定的语句进行解释，调用特定的业务代码进行执行的过程。<br></p>

<h2>中介模式</h2>

<p>1:接口对象之间的交互关系，将多对多关系通过中介类转换为一对多。<br>
2:中介模式和观察者模式的区别在于，观察者关系是单向固定的，中介则可以是双向的。<br>
3:中介模式接收消息后进行业务编排调度。<br>
4:副作用：可能会产生一个大而全的上帝类，包含类所有的业务代码。（是否可以用命令模式进行拆分？）<br></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式-面向对象编程]]></title>
    <link href="http://toby1024.github.io/blog/2020/10/23/design-pattern-rules/"/>
    <updated>2020-10-23T18:04:17+08:00</updated>
    <id>http://toby1024.github.io/blog/2020/10/23/design-pattern-rules</id>
    <content type="html"><![CDATA[<h1>面向对象</h1>

<p><img src="/images/blogs/mianxiangduixiang.png"></p>

<!--more-->


<h2>多用组合少用继承</h2>

<p>继承过多过深影响代码可读性，提高维护成本</p>

<h1>设计原则与思想</h1>

<p><img src="/images/blogs/设计原则与思想.png"></p>

<h2>单一职责原则  Single Responsibility Principle</h2>

<h3>如何理解单一职责</h3>

<p>一个类（方法）只完成一件事<br>
不要设计大而全的类（接口)<br>
高内聚低耦合<br></p>

<h3>如何判断是否职责单一</h3>

<p>类或方法无法准确命名<br>
依赖过多外部资源<br>
代码行数过多，类的属性或者函数过多<br>
类的方法都在集中操作某几个属性<br></p>

<h3>拆分粒度是否越细越好？</h3>

<p>考虑功能的相关性，避免低耦合过度失去高内聚，提高维护成本</p>

<h2>开闭原则  Open/Closed Principle</h2>

<p>对扩展开放，对修改关闭<br>
合理设计，不要过度设计<br>
职责单一，避免相互影响，保证稳定性<br></p>

<h2>DRY</h2>

<p>重复主要指：代码重复，语义重复，执行重复<br>
代码重复指的是同样的代码出现在多个地方，这种情况可以通过抽取方法，工具类的方式解决<br>
语义重复指的是相同的功能采用了不同的实现方法，出现在多个地方，这种情况可以通过抽取工具类的方法解决<br>
执行重复指的业务上下文执行了同样的逻辑，一般是参数校验，格式化等，需要从业务角度梳理，去除不必要的重复执行<br>
复用需要考虑扩展性，避免和业务耦合，保证代码的稳定性<br></p>

<h1>规范与重构</h1>

<p><img src="/images/blogs/规范与重构.png">
重构是一个持续的过程，重构不光是代码级别的重构，也针对业务架构等<br>
重构的前提是单元测试要覆盖到位</p>

<h2>如何评价代码质量的高低</h2>

<p>代码质量高低是通过综合各种因素得到的结论，常见的描述有可读性，可维护性，简洁性，灵活性等，对应的一般都是面向对象的几个特性。所以好的代码应该是面向对象的。</p>

<h2>如何写出高质量的代码</h2>

<p>需要掌握面向对象的思想，做好设计再写代码，在编码过程中灵活使用设计模式，遵循编码规范，不断的重构完善代码。
<img src="/images/DesignPatterns/20201124.jpg"></p>
]]></content>
  </entry>
  
</feed>
